---
title: "Tasks"
author: "Koji"
date: "2018/7/25"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# Project Overview

Around the world, people are spending an increasing amount of time on their mobile devices for email, social networking, banking and a whole range of other activities. But typing on mobile devices can be a serious pain. SwiftKey, our corporate partner in this capstone, builds a smart keyboard that makes it easier for people to type on their mobile devices. One cornerstone of their smart keyboard is predictive text models. When someone types:

I went to the

the keyboard presents three options for what the next word might be. For example, the three words might be gym, store, restaurant. In this capstone you will work on understanding and building predictive text models like those used by SwiftKey.


_The motivation for this project is to:_

1. Demonstrate that you've downloaded the data and have successfully loaded it in.
2. Create a basic report of summary statistics about the data sets.
3. Report any interesting findings that you amassed so far.
4. Get feedback on your plans for creating a prediction algorithm and Shiny app.

_Review criteria_

1. Does the link lead to an HTML page describing the exploratory analysis of the training data set?
2. Has the data scientist done basic summaries of the three files? Word counts, line counts and basic data tables?
3. Has the data scientist made basic plots, such as histograms to illustrate features of the data?
4. Was the report written in a brief, concise style, in a way that a non-data scientist manager could appreciate?

```{r, message=FALSE, warning=FALSE}
library(stringr)
require(quanteda)
require(readtext)
library(R.utils)
library(ggplot2)

set.seed(3301)
```

# Task 0: Understanding the problem

_Tasks to accomplish_

1. Obtaining the data - Can you download the data and load/manipulate it in R?
2. Familiarizing yourself with NLP and text mining - Learn about the basics of natural language processing and how it relates to the data science process you have learned in the Data Science Specialization.

_Questions to consider_

1. What do the data look like?
2. Where do the data come from?
3. Can you think of any other data sources that might help you in this project?
4. What are the common steps in natural language processing?
5. What are some common issues in the analysis of text data?
6. What is the relationship between NLP and the concepts you have learned in the Specialization?

Dwonload data.
```{r, message=FALSE}
source("downloadData.R")

attach(downloadData(file.path("..", "data")))
c(blogs, twitter, news, badwords)
```

First, loading in files using my poor implementation is below.
```{r eval=FALSE, include=FALSE}
tweets <- 0
wordsTwitter <- 0
sentencesTwitter <- 0
con <- file(twitter, "r")
while (length(oneLine <- readLines(con, 1, warn = FALSE)) > 0) {
        tweets <- tweets + 1
        if(tweets <= 10) {
                print(oneLine)
        }
        words <- str_split(oneLine, "\\s+")[[1]]
        symbols <- rep(FALSE, length = length(words))
        for(i in 1:length(words)) {
                symbols[i] <- grepl("^[^a-zA-Z0-9]+$", words[i])
                if(grepl("^[0-9]+$", words[i])) {
                        words[i] <- "[numbers]"
                }
        }
        wordsPerLine <- length(simpleWords <- words[!symbols])
        for(i in 1:length(simpleWords)){
                if(grepl("[.!?]$", simpleWords[i])) {
                        sentencesTwitter <- sentencesTwitter + 1
                }
        }
        wordsTwitter <- wordsTwitter + wordsPerLine
        remove(simpleWords, words)
}
close(con)

tweets
wordsTwitter
sentencesTwitter
```
```
## [1] "How are you? Btw thanks for the RT. You gonna be in DC anytime soon? Love to see you. Been way, way too long."
## [1] "When you meet someone special... you'll know. Your heart will beat more rapidly and you'll smile for no reason."
## [1] "they've decided its more fun if I don't."
## [1] "So Tired D; Played Lazer Tag & Ran A LOT D; Ughh Going To Sleep Like In 5 Minutes ;)"
## [1] "Words from a complete stranger! Made my birthday even better :)"
## [1] "First Cubs game ever! Wrigley field is gorgeous. This is perfect. Go Cubs Go!"
## [1] "i no! i get another day off from skool due to the wonderful snow (: and THIS wakes me up...damn thing"
## [1] "I'm coo... Jus at work hella tired r u ever in cali"
## [1] "The new sundrop commercial ...hehe love at first sight"
## [1] "we need to reconnect THIS WEEK"

## [1] 2360148
## [1] 29706404
## [1] 2818583
```

Next, loading in files using the readtext package
```{r}
tweetFile <- readtext(twitter)
corpusTwitter <- corpus(tweetFile, cache = FALSE)
summary(corpusTwitter)
```

# Task 1: Getting and cleaning the data

_Tasks to accomplish_

1. Tokenization - identifying appropriate tokens such as words, punctuation, and numbers. Writing a function that takes a file as input and returns a tokenized version of it.
2. Profanity filtering - removing profanity and other words you do not want to predict.


_Tips, tricks, and hints_

1. **Loading the data in.** This dataset is fairly large. We emphasize that you don't necessarily need to load the entire dataset in to build your algorithms (see point 2 below). At least initially, you might want to use a smaller subset of the data. Reading in chunks or lines using R's readLines or scan functions can be useful. You can also loop over each line of text by embedding readLines within a for/while loop, but this may be slower than reading in large chunks at a time. Reading pieces of the file at a time will require the use of a file connection in R. For example, the following code could be used to read the first few lines of the English Twitter dataset:con <- file("en_US.twitter.txt", "r") readLines(con, 1) ## Read the first line of text readLines(con, 1) ## Read the next line of text readLines(con, 5) ## Read in the next 5 lines of text close(con) ## It's important to close the connection when you are done
See the ?connections help page for more information.

2. **Sampling.** To reiterate, to build models you don't need to load in and use all of the data. Often relatively few randomly selected rows or chunks need to be included to get an accurate approximation to results that would be obtained using all the data. Remember your inference class and how a representative sample can be used to infer facts about a population. You might want to create a separate sub-sample dataset by reading in a random subset of the original data and writing it out to a separate file. That way, you can store the sample and not have to recreate it every time. You can use the rbinom function to "flip a biased coin" to determine whether you sample a line of text or not.

Sub-Sampling.
```{r}
twitterSubSampling <- paste0(twitter, ".sub-sampling.txt")
if(!file.exists(twitterSubSampling)) {
        subSamplingSize <- 10000
        flipABiasedCoin <- rbinom(tweets, size = 1, prob = subSamplingSize / tweets)
        conRead <- file(twitter, "r")
        conWrite <- file(twitterSubSampling, "w")
        len <- 0
        while (length(oneLine <- readLines(conRead, 1, warn = FALSE)) > 0) {
                len <- len + 1
                if(flipABiasedCoin[len] == 1) {
                        writeLines(oneLine, conWrite)
                }
        }
        close(conRead)
        close(conWrite)
}

subTweets <- as.numeric(countLines(twitterSubSampling))
subTweets
```

Tokenization.
```{r}
subTweetFile <- readtext(twitterSubSampling)
subTwitterCorpus <- corpus(subTweetFile, cache = FALSE)
summary(subTwitterCorpus)
```

Load bad words.
```{r}
profanity <- readLines(badwords)
```

# Task 2: Exploratory Data Analysis

_Tasks to accomplish_

1. Exploratory analysis - perform a thorough exploratory analysis of the data, understanding the distribution of words and relationship between the words in the corpora.
2. Understand frequencies of words and word pairs - build figures and tables to understand variation in the frequencies of words and word pairs in the data.

_Questions to consider_

1. Some words are more frequent than others - what are the distributions of word frequencies?
2. What are the frequencies of 2-grams and 3-grams in the dataset?
3. How many unique words do you need in a frequency sorted dictionary to cover 50% of all word instances in the language? 90%?
4. How do you evaluate how many of the words come from foreign languages?
5. Can you think of a way to increase the coverage -- identifying words that may not be in the corpora or using a smaller number of words in the dictionary to cover the same number of phrases?

|Field|Unit|Sample sequence|1-gram sequence|2-gram sequence|3-gram sequence|
|-----|----|---------------|---------------|---------------|---------------|
|Computational linguistics|word|… to be or not to be …|…, to, be, or, not, to, be, …|…, to be, be or, or not, not to, to be, …|…, to be or, be or not, or not to, not to be, …|

Top 20.
```{r}
subTweetsDfm <- dfm(subTwitterCorpus)
topfeatures(subTweetsDfm, 20)
```

Plot word cloud.
```{r, fig.width=14, fig.height=14}
subTweetsDfm %>% 
        dfm_trim(min_termfreq = 10,
                 verbose = FALSE) %>%
        textplot_wordcloud(min_count = 6,
                           random_order = FALSE, 
                           rotation = .25,
                           color = RColorBrewer::brewer.pal(8, "Dark2"))
```

Nomarize words.
```{r}
subTweetsDfmNomarized <- subTwitterCorpus %>% 
        # nomarize words
        tokens(remove_punct = TRUE,
               remove_numbers = TRUE) %>%
        # removing profanity and other words
        tokens_remove(stopwords('english')) %>%
        tokens_remove(profanity)
```

Top 20 Nomarized words.
```{r}
topfeatures(dfm(subTweetsDfmNomarized), 20)
```

Plot word cloud.
```{r, fig.width=10, fig.height=10}
dfm(subTweetsDfmNomarized) %>%
        dfm_trim(min_termfreq = 10,
                 verbose = FALSE) %>%
        textplot_wordcloud(min_count = 6,
                           random_order = FALSE,
                           max_words = 100,
                           rotation = .25,
                           color = RColorBrewer::brewer.pal(8, "Dark2"))
```

Frequency Plots
```{r}
featuresTweetsDfm <- textstat_frequency(dfm(subTweetsDfmNomarized), n = 80)

# Sort by reverse frequency order
featuresTweetsDfm$feature <- with(featuresTweetsDfm, reorder(feature, -frequency))

ggplot(featuresTweetsDfm, aes(x = feature, y = frequency)) +
        geom_point() + 
        theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

2-Gram
```{r, fig.width=14, fig.height=14}
subTweetsDfmNomarized2Gram <- subTwitterCorpus %>% 
        # nomarize words
        tokens(remove_punct = TRUE,
               remove_numbers = TRUE) %>%
        # removing profanity and other words
        tokens_remove(stopwords('english')) %>%
        tokens_remove(profanity) %>%
        tokens_ngrams(n = 2)
topfeatures(dfm(subTweetsDfmNomarized2Gram), 20)
```



```{r}
dfm(subTweetsDfmNomarized2Gram) %>%
        dfm_trim(min_termfreq = 10,
                 verbose = FALSE) %>%
        textplot_wordcloud(min_count = 6,
                           random_order = FALSE,
                           max_words = 100,
                           rotation = .25,
                           color = RColorBrewer::brewer.pal(8, "Dark2"))
```

Frequency Plots
```{r}
featuresTweetsDfm2Gram <- textstat_frequency(dfm(subTweetsDfmNomarized2Gram), n = 80)

# Sort by reverse frequency order
featuresTweetsDfm2Gram$feature <- with(featuresTweetsDfm2Gram, reorder(feature, -frequency))

ggplot(featuresTweetsDfm2Gram, aes(x = feature, y = frequency)) +
        geom_bar(stat = "identity") + 
        geom_point() + 
        theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

```{r}
featuresTweetsDfmFull <- textstat_frequency(dfm(subTweetsDfmNomarized))
summary(featuresTweetsDfmFull)
quantile(featuresTweetsDfmFull$frequency, c(0, .1, .5, .9, 1))

featuresTweetsDfm2GramFull <- textstat_frequency(dfm(subTweetsDfmNomarized2Gram))
summary(featuresTweetsDfm2GramFull)
quantile(featuresTweetsDfm2GramFull$frequency, c(0, .1, .5, .9, 1))
```

```{r}
ntoken(subTweetsDfmNomarized)
ntype(subTweetsDfmNomarized)
```

# Task 3: Modeling

_Tasks to accomplish_

1. Build basic n-gram model - using the exploratory analysis you performed, build a basic [n-gram model](https://en.wikipedia.org/wiki/N-gram) for predicting the next word based on the previous 1, 2, or 3 words.
2. Build a model to handle unseen n-grams - in some cases people will want to type a combination of words that does not appear in the corpora. Build a model to handle cases where a particular n-gram isn't observed.

_Questions to consider_

1. How can you efficiently store an n-gram model (think Markov Chains)?
2. How can you use the knowledge about word frequencies to make your model smaller and more efficient?
3. How many parameters do you need (i.e. how big is n in your n-gram model)?
4. Can you think of simple ways to "smooth" the probabilities (think about giving all n-grams a non-zero probability even if they aren't observed in the data) ?
5. How do you evaluate whether your model is any good?
6. How can you use [backoff models](https://en.wikipedia.org/wiki/Katz%27s_back-off_model) to estimate the probability of unobserved n-grams?


Basic 2-gram model:
```{r}
userInput <- "aGood"

nextWordDfm <- dfm(tokens_select(
        subTweetsDfmNomarized2Gram, 
        paste0("^", userInput, "_.*"),
        valuetype ="regex"))

if(length(nextWordDfm) > 0) {
        featuresNextWord <- textstat_frequency(nextWordDfm, n = 5)
        featuresNextWord$feature <- 
                sapply(as.vector(featuresNextWord$feature), 
                       function(x){
                               str_split(x, "_")[[1]][2]
                       })
        # Sort by reverse frequency order
        featuresNextWord$feature <- with(featuresNextWord, reorder(feature, -frequency))

        ggplot(featuresNextWord, aes(x = feature, y = frequency)) +
                geom_bar(stat = "identity") + 
                theme(axis.text.x = element_text(angle = 90, hjust = 1))
} else {
        # un-seen n-gram.
        # backoff models?
}
```

# References
- [Data Science Specialization - Capstone | Community Site](http://datasciencespecialization.github.io/capstone/)
- [Quick Start Guide • quanteda](http://docs.quanteda.io/articles/pkgdown/quickstart.html)
- [Lecture Slides from the Stanford Coursera course | Natural Language Processing](https://web.stanford.edu/~jurafsky/NLPCourseraSlides.html)
by Dan Jurafsky and Christopher Manning
- [Text Mining Infrastructure in R | Journal of Statistical Software](https://www.jstatsoft.org/article/view/v025i05/v25i05.pdf)
by Ingo Feinerer, Kurt Hornik, David Meyer, Wirtschaftsuniversita ̈t Wie
- [Speech and Language Processing (3rd ed. draft)](https://web.stanford.edu/~jurafsky/slp3/)
by Daniel Jurafsky, Stanford University, James H. Martin, University of Colorado at Boulder
- [Useful Resources from Luis von Ahn's Research Group](https://www.cs.cmu.edu/~biglou/resources/)
